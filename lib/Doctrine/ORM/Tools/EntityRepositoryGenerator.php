<?php
/*
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * and is licensed under the MIT license. For more information, see
 * <http://www.doctrine-project.org>.
 */

namespace Doctrine\ORM\Tools;

use Doctrine\ORM\Mapping\ClassMetadataInfo;
use Doctrine\Common\Util\Inflector;
use Doctrine\DBAL\Types\Type;

/**
 * Class to generate entity repository classes
 *
 *
 * @link    www.doctrine-project.org
 * @since   2.0
 * @author  Benjamin Eberlei <kontakt@beberlei.de>
 * @author  Guilherme Blanco <guilhermeblanco@hotmail.com>
 * @author  Jonathan Wage <jonwage@gmail.com>
 * @author  Roman Borschel <roman@code-factory.org>
 */
class EntityRepositoryGenerator
{
    /**
     * @var string
     */
    private $repositoryName;

    /**
     * Hash-map for handle types.
     *
     * @var array
     */
    protected $typeAlias = [
        Type::DATETIMETZ    => '\DateTime',
        Type::DATETIME      => '\DateTime',
        Type::DATE          => '\DateTime',
        Type::TIME          => '\DateTime',
        Type::OBJECT        => '\stdClass',
        Type::INTEGER       => 'int',
        Type::BIGINT        => 'int',
        Type::SMALLINT      => 'int',
        Type::TEXT          => 'string',
        Type::BLOB          => 'string',
        Type::DECIMAL       => 'string',
        Type::JSON_ARRAY    => 'array',
        Type::SIMPLE_ARRAY  => 'array',
        Type::BOOLEAN       => 'bool',
    ];

    /**
     * @var string
     */
    protected static $_template =
'<?php

<namespace>

/**
 * <className>
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class <className> extends <repositoryName>
{
}
';

    /**
     * @var string
     */
    protected static $_templateWithMagicMethodDocblocks = <<<'EOT'
<?php

<namespace>

/**
 * <className>
 *
<magicMethodDocblocks>
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class <className> extends <repositoryName>
{
}
EOT;

    /**
     * @var string
     */
    protected static $findByDocblockTemplate = <<<'EOT'
 * @method <entity>[] findBy<fieldName>(<arg1TypeHint>$<arg1Name>) Finds occurrences of <entity> matching the <arg1Name> property.
EOT;

    /**
     * @var string
     */
    protected static $findOneByDocblockTemplate = <<<'EOT'
 * @method <entity> findOneBy<fieldName>(<arg1TypeHint>$<arg1Name>) Finds a single occurrence of <entity> matching the <arg1Name> property, if any.
EOT;

    /**
     * @var string
     */
    protected static $countByDocblockTemplate = <<<'EOT'
 * @method int countBy<fieldName>(<arg1TypeHint>$<arg1Name>) Counts the number of occurrences of <entity> matching the <arg1Name> property.
EOT;

    /**
     * @param string $fullClassName
     *
     * @return string
     */
    public function generateEntityRepositoryClass($fullClassName)
    {
        $variables = [
            '<namespace>'       => $this->generateEntityRepositoryNamespace($fullClassName),
            '<repositoryName>'  => $this->generateEntityRepositoryName($fullClassName),
            '<className>'       => $this->generateClassName($fullClassName),
        ];

        return str_replace(array_keys($variables), array_values($variables), self::$_template);
    }

    /**
     * @param ClassMetadataInfo $metadata
     *
     * @return string
     */
    public function generateEntityRepositoryClassWithMagicMethodDocblocks(ClassMetadataInfo $metadata)
    {
        $variables = [
            '<namespace>'               => $this->generateEntityRepositoryNamespace($metadata->customRepositoryClassName),
            '<repositoryName>'          => $this->generateEntityRepositoryName($metadata->customRepositoryClassName),
            '<className>'               => $this->generateClassName($metadata->customRepositoryClassName),
            '<magicMethodDocblocks>'    => $this->generateDocblocksForMagicMethods($metadata),
        ];

        return str_replace(array_keys($variables), array_values($variables), self::$_templateWithMagicMethodDocblocks);
    }

    /**
     * Generates the namespace, if class do not have namespace, return empty string instead.
     *
     * @param string $fullClassName
     *
     * @return string $namespace
     */
    private function getClassNamespace($fullClassName)
    {
        $namespace = substr($fullClassName, 0, strrpos($fullClassName, '\\'));

        return $namespace;
    }

    /**
     * Generates the class name
     *
     * @param string $fullClassName
     *
     * @return string
     */
    private function generateClassName($fullClassName)
    {
        $namespace = $this->getClassNamespace($fullClassName);

        $className = $fullClassName;

        if ($namespace) {
            $className = substr($fullClassName, strrpos($fullClassName, '\\') + 1, strlen($fullClassName));
        }

        return $className;
    }

    /**
     * Generates the namespace statement, if class do not have namespace, return empty string instead.
     *
     * @param string $fullClassName The full repository class name.
     *
     * @return string $namespace
     */
    private function generateEntityRepositoryNamespace($fullClassName)
    {
        $namespace = $this->getClassNamespace($fullClassName);

        return $namespace ? 'namespace ' . $namespace . ';' : '';
    }

    /**
     * @param string $fullClassName
     *
     * @return string $repositoryName
     */
    private function generateEntityRepositoryName($fullClassName)
    {
        $namespace = $this->getClassNamespace($fullClassName);

        $repositoryName = $this->repositoryName ?: 'Doctrine\ORM\EntityRepository';

        if ($namespace && $repositoryName[0] !== '\\') {
            $repositoryName = '\\' . $repositoryName;
        }

        return $repositoryName;
    }

    /**
     * @param string $fullClassName
     * @param string $outputDirectory
     *
     * @return void
     */
    public function writeEntityRepositoryClass($fullClassName, $outputDirectory)
    {
        $code = $this->generateEntityRepositoryClass($fullClassName);

        $path = $outputDirectory . \DIRECTORY_SEPARATOR
              . str_replace('\\', \DIRECTORY_SEPARATOR, $fullClassName) . '.php';
        $dir = dirname($path);

        if ( ! is_dir($dir)) {
            mkdir($dir, 0775, true);
        }

        if ( ! file_exists($path)) {
            file_put_contents($path, $code);
            chmod($path, 0664);
        }
    }

    /**
     * @param string $repositoryName
     *
     * @return \Doctrine\ORM\Tools\EntityRepositoryGenerator
     */
    public function setDefaultRepositoryName($repositoryName)
    {
        $this->repositoryName = $repositoryName;

        return $this;
    }

    public function writeEntityRepository(ClassMetadataInfo $metadata, $outputDirectory)
    {
        $code = $this->generateEntityRepositoryClassWithMagicMethodDocblocks($metadata);

        $path = $outputDirectory . \DIRECTORY_SEPARATOR
              . str_replace('\\', \DIRECTORY_SEPARATOR, $metadata->customRepositoryClassName) . '.php';
        $dir = dirname($path);

        if ( ! is_dir($dir)) {
            mkdir($dir, 0775, true);
        }

        if ( ! file_exists($path)) {
            file_put_contents($path, $code);
            chmod($path, 0664);
        }
    }

    public function generate(array $metadatas, $outputDirectory)
    {
        foreach ($metadatas as $metadata) {
            $this->writeEntityRepository($metadata, $outputDirectory);
        }
    }

    public function generateDocblocksForMagicMethods(ClassMetadataInfo $metadata)
    {
        $docblocks = [];

        foreach ($metadata->fieldMappings as $fieldMapping) {
            if (isset($fieldMapping['declaredField']) &&
                isset($metadata->embeddedClasses[$fieldMapping['declaredField']])
            ) {
                continue;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'findBy', $fieldMapping['fieldName'], $fieldMapping['type'])) {
                $docblocks[] = $code;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'findOneBy', $fieldMapping['fieldName'], $fieldMapping['type'])) {
                $docblocks[] = $code;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'countBy', $fieldMapping['fieldName'], $fieldMapping['type'])) {
                $docblocks[] = $code;
            }
        }

        foreach ($metadata->embeddedClasses as $fieldName => $embeddedClass) {
            if (isset($embeddedClass['declaredField'])) {
                continue;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'findBy', $fieldName, $embeddedClass['class'])) {
                $docblocks[] = $code;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'findOneBy', $fieldName, $embeddedClass['class'])) {
                $docblocks[] = $code;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'countBy', $fieldName, $embeddedClass['class'])) {
                $docblocks[] = $code;
            }
        }

        foreach ($metadata->associationMappings as $associationMapping) {
            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'findBy', $associationMapping['fieldName'], $associationMapping['targetEntity'])) {
                $docblocks[] = $code;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'findOneBy', $associationMapping['fieldName'], $associationMapping['targetEntity'])) {
                $docblocks[] = $code;
            }

            if ($code = $this->generateDocblocksForMagicMethod($metadata, 'countBy', $associationMapping['fieldName'], $associationMapping['targetEntity'])) {
                $docblocks[] = $code;
            }
        }

        return implode("\n", $docblocks);
    }

    protected function generateDocblocksForMagicMethod(ClassMetadataInfo $metadata, $type, $fieldName, $typeHint = null)
    {
        $variableName = Inflector::camelize($fieldName);
        $var = sprintf('%sDocblockTemplate', $type);
        $template = static::$$var;

        $methodTypeHint = null;
        $types          = Type::getTypesMap();
        $variableType   = $typeHint ? $this->getType($typeHint) : null;

        if ($typeHint && ! isset($types[$typeHint])) {
            $variableType   =  '\\' . ltrim($variableType, '\\');
            $methodTypeHint =  '\\' . $typeHint . ' ';
        }

        $replacements = [
            '<entity>'          => $this->getClassName($metadata),
            '<arg1TypeHint>'        => $variableType ? ($variableType . ' ') : '',
            '<arg1Name>'            => $variableName,
            '<fieldName>'           => ucfirst($fieldName),
        ];

        $docblock = str_replace(
            array_keys($replacements),
            array_values($replacements),
            $template
        );

        return $docblock;
    }

    /**
     * @param string $type
     *
     * @return string
     */
    protected function getType($type)
    {
        if (isset($this->typeAlias[$type])) {
            return $this->typeAlias[$type];
        }

        return $type;
    }

    /**
     * @param ClassMetadataInfo $metadata
     *
     * @return string
     */
    protected function getClassName(ClassMetadataInfo $metadata)
    {
        return ($pos = strrpos($metadata->name, '\\'))
            ? substr($metadata->name, $pos + 1, strlen($metadata->name)) : $metadata->name;
    }

    /**
     * @param array $associationMapping
     *
     * @return bool
     */
    protected function isAssociationIsNullable($associationMapping)
    {
        if (isset($associationMapping['id']) && $associationMapping['id']) {
            return false;
        }

        if (isset($associationMapping['joinColumns'])) {
            $joinColumns = $associationMapping['joinColumns'];
        } else {
            //@todo there is no way to retrieve targetEntity metadata
            $joinColumns = [];
        }

        foreach ($joinColumns as $joinColumn) {
            if (isset($joinColumn['nullable']) && !$joinColumn['nullable']) {
                return false;
            }
        }

        return true;
    }
}
